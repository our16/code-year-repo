# 自动续跑和完全重跑功能说明

## 📋 需求描述

**用户需求**：
1. **服务启动自动续跑**：服务器启动时自动检测未完成的任务并继续执行，无需用户点击开始按钮
2. **完全重跑按钮**：提供一个"完全重跑"按钮，可以清除所有进度和报告文件，从头开始生成

## 🔧 实现方案

### 1. 服务启动自动续跑

#### 工作原理

服务器启动时自动检查 `reports/.progress.json` 文件：

1. **检测未完成任务**：读取进度文件，检查 `status` 是否为 `generating`
2. **自动启动续跑**：如果检测到未完成任务，自动在后台线程中启动报告生成
3. **智能续跑**：利用现有的检查点机制，跳过已完成的Git采集，直接续跑LLM分析

#### 实现代码

**文件**: [src/server.py](src/server.py) 第945-970行

```python
def start_server(port: int = 8000, reports_dir: str = './reports'):
    """启动Web服务器"""

    # ... 前面的代码 ...

    # 检查是否有未完成的任务，自动续跑
    progress_file = reports_path / '.progress.json'
    if progress_file.exists():
        try:
            with open(progress_file, 'r', encoding='utf-8') as f:
                progress = json.load(f)

            if progress.get('status') == 'generating':
                logger.info("=" * 60)
                logger.info("检测到未完成的生成任务，自动续跑")
                logger.info("=" * 60)
                logger.info(f"任务进度: {progress.get('completed', 0)}/{progress.get('total', 0)}")

                # 在后台线程中自动续跑
                def auto_resume():
                    try:
                        generator = ReportGenerator(str(reports_path))
                        generator.generate_all()
                    except Exception as e:
                        logger.error(f"自动续跑失败: {e}")

                resume_thread = threading.Thread(target=auto_resume, daemon=True)
                resume_thread.start()
                logger.info("已在后台启动自动续跑任务")
        except Exception as e:
            logger.warning(f"检查进度文件失败: {e}")

    # ... 后面的代码 ...
```

#### 使用场景

**场景1：服务器意外停止后重启**
```
1. 报告生成进行中（如已完成 5/10）
2. 服务器意外停止（断电、崩溃等）
3. 重新启动服务器
4. 自动检测到未完成任务
5. 自动从断点继续（从第6个开始）
6. 无需任何手动操作
```

**场景2：正常启动但历史任务未完成**
```
1. 上次的报告生成被中断
2. 重新启动服务器
3. 自动续跑，用户访问页面时看到进度条
4. 任务自动完成
```

#### 日志输出

```
============================================================
检测到未完成的生成任务，自动续跑
============================================================
任务进度: 5/10
已在后台启动自动续跑任务
```

### 2. 完全重跑功能

#### 功能描述

"完全重跑"按钮会清除以下内容：
1. ✅ 进度文件（`.progress.json`）
2. ✅ 续跑检查点（`.resume_checkpoint.json`）
3. ✅ 所有已生成的报告文件（`*.json`）

然后从头开始生成所有报告。

#### UI界面

**文件**: [static/overview.html](static/overview.html) 第18-20行

```html
<button id="rerunBtn" class="rerun-btn" onclick="completelyRerun()">
    🔃 完全重跑
</button>
```

**样式设计**：
- 按钮颜色：红色系（`rgba(255, 100, 100, 0.2)`）
- 与"生成报告"按钮并列显示
- 鼠标悬停时颜色加深

#### 用户交互流程

```
1. 用户点击"🔃 完全重跑"按钮
   ↓
2. 弹出确认对话框：
   ⚠️ 完全重跑将清除以下内容：

   • 所有进度文件
   • 续跑检查点
   • 所有已生成的报告文件

   确定要从头开始生成吗？
   ↓
3. 用户点击"确定"
   ↓
4. 发送 POST /api/completely-rerun 请求
   ↓
5. 后端删除文件并启动新任务
   ↓
6. 前端显示成功提示：
   ✅ 已清除历史数据，从头开始生成
   已删除: .progress.json, .resume_checkpoint.json, 10 个报告文件
   ↓
7. 两个按钮都显示"⏳ 生成中..."
   ↓
8. 自动开始显示进度条
```

#### 后端API实现

**文件**: [src/server.py](src/server.py) 第564-641行

```python
def completely_rerun(self):
    """完全重跑 - 清除所有进度和检查点，从头开始生成"""
    try:
        logger.info("=" * 60)
        logger.info("收到完全重跑请求")
        logger.info("=" * 60)

        project_root = Path(__file__).parent.parent
        reports_dir = project_root / 'reports'

        # 1. 删除进度文件
        progress_file = reports_dir / '.progress.json'
        deleted_files = []

        if progress_file.exists():
            try:
                progress_file.unlink()
                deleted_files.append('.progress.json')
                logger.info("已删除进度文件")
            except Exception as e:
                logger.warning(f"删除进度文件失败: {e}")

        # 2. 删除续跑检查点文件
        checkpoint_file = reports_dir / '.resume_checkpoint.json'
        if checkpoint_file.exists():
            try:
                checkpoint_file.unlink()
                deleted_files.append('.resume_checkpoint.json')
                logger.info("已删除续跑检查点文件")
            except Exception as e:
                logger.warning(f"删除检查点文件失败: {e}")

        # 3. 删除所有旧报告文件
        if reports_dir.exists():
            json_files = list(reports_dir.glob('*.json'))
            report_count = 0
            for json_file in json_files:
                if not json_file.name.startswith('.'):
                    try:
                        json_file.unlink()
                        report_count += 1
                    except Exception as e:
                        logger.warning(f"删除报告文件失败 {json_file}: {e}")

            if report_count > 0:
                deleted_files.append(f"{report_count} 个报告文件")
                logger.info(f"已删除 {report_count} 个报告文件")

        logger.info("=" * 60)
        logger.info("完全重跑：已清除所有历史数据")
        logger.info(f"删除的文件: {', '.join(deleted_files)}")
        logger.info("=" * 60)

        # 启动全新生成任务
        def run_generation():
            generator = ReportGenerator(project_root)
            def progress_callback(data):
                logger.info(f"进度: {data['current']} - {data['percentage']}%")

            generator.generate_all(progress_callback)

        thread = threading.Thread(target=run_generation, daemon=True)
        thread.start()

        response = {
            'success': True,
            'message': '已清除所有进度和报告，从头开始生成',
            'deleted_files': deleted_files
        }
        self.send_json_response(response)

    except Exception as e:
        logger.error(f"完全重跑失败: {str(e)}", exc_info=True)
        response = {
            'success': False,
            'error': str(e)
        }
        self.send_json_response(response)
```

#### 前端实现

**文件**: [static/js/overview.js](static/js/overview.js) 第592-673行

```javascript
// 完全重跑
async function completelyRerun() {
    // 1. 确认对话框
    if (!confirm('⚠️ 完全重跑将清除以下内容：\n\n• 所有进度文件\n• 续跑检查点\n• 所有已生成的报告文件\n\n确定要从头开始生成吗？')) {
        return;
    }

    const btn = document.getElementById('rerunBtn');
    const generateBtn = document.getElementById('generateBtn');

    try {
        // 2. 禁用两个按钮
        btn.disabled = true;
        generateBtn.disabled = true;

        // 3. 发送完全重跑请求
        const response = await fetch('/api/completely-rerun', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        const data = await response.json();

        if (data.success) {
            // 4. 显示成功提示
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                z-index: 1000;
                animation: slideIn 0.3s ease;
            `;
            toast.textContent = `✅ 已清除历史数据，从头开始生成`;

            if (data.deleted_files && data.deleted_files.length > 0) {
                toast.textContent += `\n\n已删除: ${data.deleted_files.join(', ')}`;
            }

            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 5000);

            // 5. 更新按钮状态
            btn.textContent = '⏳ 生成中...';
            generateBtn.textContent = '⏳ 生成中...';

            // 6. 开始显示进度
            checkProgress();
        } else {
            throw new Error(data.error || '完全重跑失败');
        }
    } catch (error) {
        console.error('完全重跑失败:', error);

        // 恢复按钮状态
        btn.disabled = false;
        generateBtn.disabled = false;

        // 显示错误提示
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1000;
        `;
        toast.textContent = `❌ ${error.message}`;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
}
```

### 3. 按钮状态管理

#### 按钮状态同步

两个按钮（"生成报告"和"完全重跑"）的状态始终保持同步：

| 系统状态 | 生成报告按钮 | 完全重跑按钮 |
|---------|------------|------------|
| 无任务，无旧报告 | 🔄 生成报告（启用） | 🔃 完全重跑（启用） |
| 无任务，有旧报告 | 🔄 重新生成报告 旧: N个（启用） | 🔃 完全重跑（启用） |
| 任务进行中 | ⏳ 生成中...（禁用） | ⏳ 生成中...（禁用） |
| 任务完成 | 🔄 生成报告（启用） | 🔃 完全重跑（启用） |

#### 代码实现

**页面加载时** ([static/js/overview.js](static/js/overview.js) 第7-67行)：
```javascript
document.addEventListener('DOMContentLoaded', async function() {
    const generateBtn = document.getElementById('generateBtn');
    const rerunBtn = document.getElementById('rerunBtn');

    // 如果有正在进行的任务
    if (statusData.has_progress) {
        // 禁用所有按钮
        generateBtn.disabled = true;
        generateBtn.textContent = '⏳ 生成中...';
        rerunBtn.disabled = true;
        rerunBtn.textContent = '⏳ 生成中...';

        // 自动显示进度条
        checkProgress();
    } else {
        // 启用所有按钮
        generateBtn.disabled = false;
        rerunBtn.disabled = false;
    }
});
```

**开始生成时** ([static/js/overview.js](static/js/overview.js) 第210-246行)：
```javascript
function startGeneration() {
    const generateBtn = document.getElementById('generateBtn');
    const rerunBtn = document.getElementById('rerunBtn');

    // 禁用两个按钮
    generateBtn.disabled = true;
    generateBtn.textContent = '⏳ 生成中...';
    rerunBtn.disabled = true;
    rerunBtn.textContent = '⏳ 生成中...';

    // 开始检查进度
    checkProgress();
}
```

**任务完成时** ([static/js/overview.js](static/js/overview.js) 第295-314行)：
```javascript
function displayProgress(progress) {
    if (progress.status === 'completed') {
        // 重新启用所有按钮
        const generateBtn = document.getElementById('generateBtn');
        const rerunBtn = document.getElementById('rerunBtn');
        if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.textContent = '🔄 生成报告';
        }
        if (rerunBtn) {
            rerunBtn.disabled = false;
        }

        // 3秒后刷新页面
        setTimeout(() => {
            location.reload();
        }, 3000);
    }
}
```

## 📊 功能对比

### 生成报告 vs 完全重跑

| 特性 | 🔄 生成报告 | 🔃 完全重跑 |
|------|------------|------------|
| 删除进度文件 | 可选（取决于操作） | ✅ 总是删除 |
| 删除检查点 | ❌ 不删除 | ✅ 总是删除 |
| 删除旧报告 | 可选（询问用户） | ✅ 总是删除 |
| 续跑支持 | ✅ 支持 | ❌ 不支持（总是从头开始） |
| 使用场景 | 正常生成/续跑 | 彻底重新生成 |

### 三种操作模式对比

| 模式 | 进度文件 | 检查点 | 旧报告 | Git采集 | LLM分析 |
|------|---------|--------|--------|---------|----------|
| **续跑 (continue)** | 保留 | 使用 | 保留 | ✅ 跳过 | ✅ 继续 |
| **重新生成 (restart)** | 删除 | 删除 | 删除 | ✅ 执行 | ✅ 执行 |
| **完全重跑 (completely-rerun)** | 删除 | 删除 | 删除 | ✅ 执行 | ✅ 执行 |

**区别**：
- **续跑**：利用检查点，跳过快速的Git采集，只续跑慢速的LLM分析
- **重新生成**：删除旧报告，从头开始完整流程
- **完全重跑**：除了删除旧报告，还明确删除所有隐藏文件（进度、检查点）

## 🎯 使用场景

### 场景1：服务器意外停止，自动续跑

```
1. 报告生成进行中（已完成Git采集，生成到 3/10）
2. 服务器崩溃/断电
3. 重启服务器: python main.py
4. 服务器自动检测到 .progress.json，status='generating'
5. 自动启动续跑线程
6. 跳过Git采集（使用检查点）
7. 从第4个作者继续LLM分析
8. 用户访问页面看到进度条自动更新
9. 任务自动完成
```

**优势**：
- ✅ 无需手动操作
- ✅ 自动从断点继续
- ✅ 节省时间（跳过Git采集）

### 场景2：需要重新生成所有报告

```
1. 发现配置错误（如年份配置不对）
2. 修改配置文件
3. 点击"🔃 完全重跑"
4. 确认删除
5. 清除所有历史数据
6. 从头开始生成
```

**优势**：
- ✅ 一键清除所有历史
- ✅ 确保完全重新生成
- ✅ 避免旧数据干扰

### 场景3：正常生成（有旧报告）

```
1. 已经有10个报告
2. 点击"🔄 生成报告"
3. 提示：发现 10 个旧报告文件
4. 选择：
   - 确定 → 删除旧报告并重新生成
   - 取消 → 保留旧报告并追加新报告
```

**优势**：
- ✅ 灵活选择
- ✅ 支持追加模式
- ✅ 避免误删除

## 🔍 技术细节

### 1. 自动续跑的触发条件

```python
if progress_file.exists():
    progress = json.load(progress_file)
    if progress.get('status') == 'generating':
        # 触发自动续跑
```

**条件**：
1. `.progress.json` 文件存在
2. `status` 字段为 `generating`

### 2. 删除文件的安全策略

```python
# 只删除非隐藏文件
for json_file in json_files:
    if not json_file.name.startswith('.'):
        json_file.unlink()
```

**规则**：
- ✅ 删除：`Author_Name.json`
- ❌ 保留：`.progress.json`, `.resume_checkpoint.json`

但在"完全重跑"模式下，会明确删除这些隐藏文件。

### 3. 后台线程的守护模式

```python
resume_thread = threading.Thread(target=auto_resume, daemon=True)
resume_thread.start()
```

**daemon=True**：
- 线程随主线程退出而退出
- 避免僵尸线程
- 服务器关闭时自动停止

### 4. 错误处理

```python
try:
    generator = ReportGenerator(str(reports_path))
    generator.generate_all()
except Exception as e:
    logger.error(f"自动续跑失败: {e}")
    # 不影响服务器启动
```

**容错性**：
- 自动续跑失败不影响服务器启动
- 错误仅记录日志
- 用户仍可手动操作

## 🧪 测试步骤

### 测试1：自动续跑

```bash
1. 启动生成任务
2. 等待进度显示（如 2/10）
3. 强制停止服务器 (Ctrl+C)
4. 重新启动服务器: python main.py
5. 观察日志输出：
   ============================================================
   检测到未完成的生成任务，自动续跑
   ============================================================
   任务进度: 2/10
   已在后台启动自动续跑任务
6. 访问页面，观察进度条自动更新
7. 等待任务完成
```

**预期结果**：
- ✅ 日志显示检测到未完成任务
- ✅ 自动启动续跑
- ✅ 进度条自动更新
- ✅ 任务从断点继续

### 测试2：完全重跑

```bash
1. 确保存在一些报告文件（如5个）
2. 访问页面
3. 点击"🔃 完全重跑"
4. 点击确定
5. 观察提示信息
6. 检查 reports/ 目录
```

**预期结果**：
- ✅ 弹出确认对话框
- ✅ 显示删除的文件列表
- ✅ reports/ 目录清空（除了隐藏文件）
- ✅ 隐藏文件也被删除
- ✅ 从头开始生成

### 测试3：按钮状态同步

```bash
1. 访问页面（无任务）
2. 检查两个按钮都启用
3. 点击"生成报告"
4. 检查两个按钮都显示"⏳ 生成中..."并禁用
5. 等待完成
6. 检查两个按钮都恢复启用
```

**预期结果**：
- ✅ 两个按钮状态始终同步
- ✅ 生成时都禁用
- ✅ 完成后都启用

### 测试4：续跑 vs 完全重跑

```bash
# 续跑测试
1. 生成过程中停止（进度文件存在）
2. 重启服务器
3. 观察日志：使用检查点，跳过Git采集

# 完全重跑测试
1. 生成过程中停止
2. 访问页面，点击"完全重跑"
3. 观察日志：删除检查点，从头开始
```

**预期结果**：
- ✅ 续跑：跳过Git采集，快速开始
- ✅ 完全重跑：删除检查点，完整流程

## 📄 修改文件清单

### 后端

- **[src/server.py](src/server.py)**
  - 第945-970行：添加服务器启动时的自动续跑逻辑
  - 第187-190行：添加 `/api/completely-rerun` 路由
  - 第564-641行：实现 `completely_rerun()` 方法

### 前端

- **[static/overview.html](static/overview.html)**
  - 第18-20行：添加"完全重跑"按钮

- **[static/css/overview.css](static/css/overview.css)**
  - 第41-75行：添加"完全重跑"按钮样式

- **[static/js/overview.js](static/js/overview.js)**
  - 第7-67行：更新页面加载初始化，管理两个按钮状态
  - 第210-246行：更新 `startGeneration()` 函数，禁用两个按钮
  - 第295-314行：更新 `displayProgress()` 函数，任务完成时启用两个按钮
  - 第592-673行：添加 `completelyRerun()` 函数
  - 第111, 129, 158, 176, 195行：更新 `startGeneration()` 调用（移除参数）

## ✅ 总结

### 实现的功能

1. ✅ **服务启动自动续跑**
   - 服务器启动时自动检测未完成任务
   - 在后台线程中自动续跑
   - 利用检查点机制，跳过Git采集
   - 无需用户手动操作

2. ✅ **完全重跑按钮**
   - 一键清除所有进度和报告
   - 明确删除隐藏文件（进度、检查点）
   - 从头开始完整生成流程
   - 友好的确认提示

3. ✅ **按钮状态同步**
   - 两个按钮状态始终保持一致
   - 页面加载时自动判断
   - 生成时都禁用
   - 完成时都启用

### 使用体验

**用户视角**：
1. 服务器意外停止 → 重启服务器 → 自动续跑，无需操作
2. 需要重新生成 → 点击"完全重跑" → 确认 → 自动开始
3. 正常使用 → 两个按钮状态清晰，操作直观

**管理员视角**：
1. 部署服务器 → 服务器启动时自动检测并续跑
2. 维护服务器 → 一键完全重跑，快速清理
3. 日志监控 → 清晰的续跑和重跑日志

### 技术优势

- ✅ **自动化**：服务器启动自动续跑，无需人工干预
- ✅ **智能化**：利用检查点机制，跳过快速操作
- ✅ **安全性**：明确的确认提示，避免误操作
- ✅ **可靠性**：错误处理完善，不影响服务器启动
- ✅ **一致性**：按钮状态同步，用户体验统一

---

**实现时间**: 2025-12-28
**版本**: v1.6.0
**作者**: Claude Code
